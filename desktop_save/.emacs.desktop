;; -*- mode: emacs-lisp; coding: emacs-mule; -*-
;; --------------------------------------------------------------------------
;; Desktop File for Emacs
;; --------------------------------------------------------------------------
;; Created Mon Jul  9 16:05:38 2018
;; Desktop file format version 208
;; Emacs version 25.3.1

;; Global section:
(setq desktop-saved-frameset [frameset 1 (23363 2370 202356 0) (desktop . "208") "freedom@freedoms-MacBook-Air.local" nil nil ((((font-backend mac-ct) (fontsize . 0) (font . "-*-Menlo-normal-normal-normal-*-12-*-*-*-m-0-iso10646-1") (border-width . 0) (internal-border-width . 2) (vertical-scroll-bars . right) (horizontal-scroll-bars) (foreground-color . "gray80") (background-color . "#181a26") (line-spacing) (left-fringe . 8) (right-fringe . 8) (menu-bar-lines . 0) (tool-bar-lines . 0) (title) (icon-type) (auto-raise) (auto-lower) (cursor-type . box) (scroll-bar-width . 15) (scroll-bar-height . 0) (alpha) (fullscreen) (display-type . color) (background-mode . dark) (cursor-color . "green") (environment) (powerline-cache) (frameset--id . "8220-8FAB-4CF8-E080") (frameset--mini t . t) (modeline . t) (minibuffer . t) (unsplittable) (right-divider-width . 0) (bottom-divider-width . 0) (icon-name) (visibility . t) (display . "freedoms-MacBook-Air.local") (explicit-name) (tool-bar-position . top) (height . 60) (width . 97) (left . 722) (top . 23)) ((min-height . 4) (min-width . 10) (min-height-ignore . 4) (min-width-ignore . 9) (min-height-safe . 1) (min-width-safe . 2) (min-pixel-height . 56) (min-pixel-width . 70) (min-pixel-height-ignore . 56) (min-pixel-width-ignore . 63) (min-pixel-height-safe . 14) (min-pixel-width-safe . 14)) leaf (pixel-width . 710) (pixel-height . 826) (total-width . 101) (total-height . 59) (normal-height . 1.0) (normal-width . 1.0) (buffer "liblary.cpp" (selected . t) (hscroll . 0) (fringes 8 8 nil) (margins 2) (scroll-bars nil 3 t nil 0 nil) (vscroll . 0) (dedicated) (point . 8) (start . 1))))])
(setq desktop-missing-file-warning nil)
(setq tags-file-name nil)
(setq tags-table-list nil)
(setq search-ring '("2N" "bash" "ba" "bash" "13" "bash" "tabbar" "unset" "cin" "bash" "cpp" "meiro" "mp" "section" "meiro" "q"))
(setq regexp-search-ring nil)
(setq register-alist nil)
(setq file-name-history '("~/.emacs.d/init.el" "~/coder/ISU.cpp" "~/coder/C/2D_Plane_2N_Points.cpp" "~/test/test002.cpp" "~/test/test.cpp" "~/coder/Minesweeper.cpp" "~/coder/typical/001_A.cpp" "~/.bashrc" "~/MyPrograms/input.txt" "~/WOJ/kadai13forSubm.cpp" "~/WOJ/kadai13forSubm2.cpp" "~/WOJ/kadai13forSubm2" "~/coder/Minesweeper2.cpp" "~/coder/Minesweeper3.cpp" "~/coder/Minesweeper4.cpp" "~/coder/20180407/A.cpp" "~/WOJ/kadai13.cpp" "~/coder/TwoColorsCardGame2.cpp~" "~/coder/hinamatsuri.cpp" "~/coder/LucasNumber.cpp" "~/.emacs.d/mysnippets/c++-mode/prtf.cpp" "~/coder/SomeSums.cpp"))
(setq kill-ring '("  vector< vector<char> > meiro(R+3,vector<char>(C+3,'0'));\n  vector< vector<int> > memo(R+3,vector<int>(C+3,mod));\n\n  vector<point_t> moves{MP(-1,0),MP(0,1),MP(1,0),MP(0,-1)};\n" "Misterious Gems" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nint solve(int );\n\nint main(void){\n  int N;\n\n  while(1) {\n    cin>>N;\n    if(N==0) return 0;\n    else solve(N);\n  }\n  return 0;\n}\n\nint solve(int N){\n  vector<int> score(N);\n  FOR(i,0,N){\n    cin>>score[i];\n  }\n  sort( score.begin(),score.end() );\n\n  int sum;\n  FOR(i,1,N-1){\n    sum += score[i];\n  }\n  int ans = sum/(N-2);\n  cout<<ans<<endl;\n  sum=0;\n}\n" "3\n1000\n342\n0\n5\n2\n2\n9\n11\n932\n5\n300\n1000\n0\n200\n400\n8\n353\n242\n402\n274\n283\n132\n402\n523\n0" "  int N;\n\n  while(1){j\n    cin>>N;\n    if(N==0) return 0;\n    else solve(N);\n  }\n  return 0;\n" "int solve(int );" "ICPC Score Totalizer Software" "/*\n  #’Ìä’Âê’¡§\n  \n\n\n  #’Ê¬’ÀÏ’¡§\n  #’¥ª’¥Ö’¥¸’¥§’¥¯’¥È’¡§\n  \n  #’¾ò’·ï’¡§\n  \n\n  #’Í×’µá’¡§\n  \n\n  #’²ò’Ë¡’¡§\n  \n*/\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define FORQD(i,b,e) for(int i=(b);i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\ntypedef pair<int, int> point_t;\npoint_t operator+( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n  return p;\n}\n\npoint_t operator-( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first - rhs.first, lhs.second - rhs.second);\n  return p;\n}\n\n\nbool operator==(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first == rhs.first) && (lhs.second == rhs.second);\n}\n\nbool operator!=(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first != rhs.first) || (lhs.second != rhs.second);\n}\n\nbool is_in_field(int row, int col,  point_t &point){\n  const int r = point.first;\n  const int c = point.second;\n  return (1<= c && c<=col) && (1 <= r && r <= row);\n}\n\n\nint main(void) {\n  int N;\n  cin>>N;\n  vector< vector<int> > memo(2*N, vector<int>(2*N));\n  FOR(i,1,2*N){\n    FORQ(j,1,2*N){\n      memo[i][j]=0;\n    }\n  }\n\n  int red_y,red_x, blue_y, blue_x;\n  vector<point_t> redv(N);\n  FOR(i,0,N) {\n    cin>>red_y>>red_x;\n    redv[i].ST=red_y; redv[i].ND=red_x;\n    memo[red_y][red_x]=1;\n  }\n\n  vector<point_t> bluev(N);\n  FOR(i,0,N){\n    // //cout<<\"i: \"<<i<<\" \"<<\"j: \"<< j<<endl;\n    cin>>blue_y>>blue_x;\n    bluev[i].ST=blue_y; bluev[i].ND=blue_x;\n    memo[blue_y][blue_x]=2;\n  }\n\n  int cnt_red=0;\n  int cnt_blue=0;\n  FOR(i,0,2*N){\n    FOR(j,0,2*N){\n      //cout<<memo[i][j];\n    }\n    //cout<<endl;\n  }\n\n  int redflag=0;\n  for(auto x:redv){\n    // memo[x.ST][x.ND]’¤Ë’¤Ä’¤¤’¤Æ\n    //cout<<\"red’ÅÀ(\"<<x.ST<<\",\"<<x.ND<<\")’¤Ë’¤Ä’¤¤’¤Æ’¹Í’¤¨’¤ë\"<<endl;\n    FORQ(i,x.ST+1,2*N-1){\n      FORQ(j,x.ND+1,2*N-1){\n        if(memo[i][j]==2){\n          redflag=1;\n          break;\n        }\n      }\n    }\n    if(redflag==0) cnt_red++;\n    redflag=0;\n  }\n  //cout<<\"cnt_red: \"<<cnt_red<<endl;\n\n  int blueflag=0;\n  for(auto x:bluev){\n    // memo[x.ST][x.ND]’¤Ë’¤Ä’¤¤’¤Æ\n    //cout<<\"blue’ÅÀ(\"<<x.ST<<\",\"<<x.ND<<\")’¤Ë’¤Ä’¤¤’¤Æ’¹Í’¤¨’¤ë\"<<endl;\n    FORQD(i,x.ST-1,0){\n      FORQD(j,x.ND-1,0){\n        if(memo[i][j]==1){\n          blueflag=1;\n          break;\n        }\n      }\n    }\n    if(blueflag==0) cnt_blue++;\n    blueflag=0;\n  }\n  //cout<<\"cnt_blue: \"<<cnt_blue<<endl;\n\n  //cout<<\"ans: \";\n  cout<<N-max(cnt_blue,cnt_red)<<endl;\n  return 0;\n}\n\n" "/*\n  #’Ìä’Âê’¡§\n  \n\n\n  #’Ê¬’ÀÏ’¡§\n  #’¥ª’¥Ö’¥¸’¥§’¥¯’¥È’¡§\n  \n  #’¾ò’·ï’¡§\n  \n\n  #’Í×’µá’¡§\n  \n\n  #’²ò’Ë¡’¡§\n  \n*/\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define FORQD(i,b,e) for(int i=(b);i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\ntypedef pair<int, int> point_t;\npoint_t operator+( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n  return p;\n}\n\npoint_t operator-( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first - rhs.first, lhs.second - rhs.second);\n  return p;\n}\n\n\nbool operator==(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first == rhs.first) && (lhs.second == rhs.second);\n}\n\nbool operator!=(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first != rhs.first) || (lhs.second != rhs.second);\n}\n\nbool is_in_field(int row, int col,  point_t &point){\n  const int r = point.first;\n  const int c = point.second;\n  return (1<= c && c<=col) && (1 <= r && r <= row);\n}\n\n\nint main(void) {\n  int N;\n  cin>>N;\n  vector< vector<int> > memo(2*N, vector<int>(2*N));\n  FOR(i,1,2*N){\n    FORQ(j,1,2*N){\n      memo[i][j]=0;\n    }\n  }\n\n  int red_y,red_x, blue_y, blue_x;\n  vector<point_t> redv(N);\n  FOR(i,0,N) {\n    cin>>red_y>>red_x;\n    redv[i].ST=red_y; redv[i].ND=red_x;\n    memo[red_y][red_x]=1;\n  }\n\n  vector<point_t> bluev(N);\n  FOR(i,0,N){\n    // cout<<\"i: \"<<i<<\" \"<<\"j: \"<< j<<endl;\n    cin>>blue_y>>blue_x;\n    bluev[i].ST=blue_y; bluev[i].ND=blue_x;\n    memo[blue_y][blue_x]=2;\n  }\n\n  int cnt_red=0;\n  int cnt_blue=0;\n  FOR(i,0,2*N){\n    FOR(j,0,2*N){\n      cout<<memo[i][j];\n    }\n    cout<<endl;\n  }\n\n  int redflag=0;\n  for(auto x:redv){\n    // memo[x.ST][x.ND]’¤Ë’¤Ä’¤¤’¤Æ\n    cout<<\"red’ÅÀ(\"<<x.ST<<\",\"<<x.ND<<\")’¤Ë’¤Ä’¤¤’¤Æ’¹Í’¤¨’¤ë\"<<endl;\n    FORQ(i,x.ST+1,2*N-1){\n      FORQ(j,x.ND+1,2*N-1){\n        if(memo[i][j]==2){\n          redflag=1;\n          break;\n        }\n      }\n    }\n    if(redflag==0) cnt_red++;\n    redflag=0;\n  }\n  cout<<\"cnt_red: \"<<cnt_red<<endl;\n\n  int blueflag=0;\n  for(auto x:bluev){\n    // memo[x.ST][x.ND]’¤Ë’¤Ä’¤¤’¤Æ\n    cout<<\"blue’ÅÀ(\"<<x.ST<<\",\"<<x.ND<<\")’¤Ë’¤Ä’¤¤’¤Æ’¹Í’¤¨’¤ë\"<<endl;\n    FORQD(i,x.ST-1,0){\n      FORQD(j,x.ND-1,0){\n        if(memo[i][j]==1){\n          blueflag=1;\n          break;\n        }\n      }\n    }\n    if(blueflag==0) cnt_blue++;\n    blueflag=0;\n  }\n  cout<<\"cnt_blue: \"<<cnt_blue<<endl;\n\n  cout<<\"ans: \";\n  cout<<N-max(cnt_blue,cnt_red)<<endl;\n  return 0;\n}\n\n" "5\n0 0\n1 1\n5 5\n6 6\n7 7\n2 2\n3 3\n4 4\n8 8\n9 9\n" "2\n2 2\n3 3\n0 0\n1 1\n" "3\n0 0\n1 1\n5 2\n2 3\n3 4\n4 5\n" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "x.ND-1" "x.ST-1" "#define FOR(i,b,e) for(int i=(b);i<(e);++i)" "  int redflag=0;" "" "  for(auto x:bluev){\n    // memo[x.ST][x.ND]’¤Ë’¤Ä’¤¤’¤Æ\n    cout<<\"red’ÅÀ(\"<<x.ST<<\",\"<<x.ND<<\")’¤Ë’¤Ä’¤¤’¤Æ’¹Í’¤¨’¤ë\"<<endl;\n    FORQ(i,x.ST+1,2*N-1){\n      FORQ(j,x.ND+1,2*N-1){\n        if(memo[i][j]==2){\n          redflag=1;\n          break;\n        }\n      }\n    }\n    if(redflag==1) cnt_red++;\n    redflag=0;\n  }\n  cout<<\"cnt_red: \"<<cnt_red<<endl;\n" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "  vector<point_t> redv[N];" "  int red_y,red_x, blue_y, blue_x;" "    redv[i].ST=red_y; redv[i].ND=red_x;" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "    }" " FORQ(j,1,N){" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "      cout<<\"i: \"<<i<<\" \"<<\"j: \"<< j<<endl;" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "  FORQ(i,1,N){\n    FORQ(j,1,N){\n      cin>>blue_y>>blue_x;\n      memo[blue_y][blue_x]=1;\n    }\n  }\n" "  FORQ(i,1,N){\n    FORQ(j,1,N){\n      cin>>ay>>ax;\n      memo[ay][ax]=1;\n    }\n  }\n" "vector< vector<int> > memo(N+1, vector<int>(N+1));" "  for(int i=N;i>=0;i--){" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nint main(void){\n  int X,Y,Z;\n  int ans;\n\n  cin>>X>>Y>>Z;\n  ans = (X-Z)/(Y+Z);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n" "/*\n  #’Ìä’Âê’¡§\n  \n\n\n  #’Ê¬’ÀÏ’¡§\n  #’¥ª’¥Ö’¥¸’¥§’¥¯’¥È’¡§\n  ’¡Ö’¡Ö’ÉýX’¥»’¥ó’¥Á’¥á’¡¼’¥È’¥ë’¡×’¤Î’°Ø’»Ò’¡×\n  ’¿Í’¤Ï’¡Ö’¡ÖY’¥»’¥ó’¥Á’¥á’¡¼’¥È’¥ë’¡×’¤Î’Éý’¡×’¤ò’»È’¤¦\n  ’¡Ö’¿Í’¤È’¿Í’¤Î’´ÖZ’¥»’¥ó’¥Á’¥á’¡¼’¥È’¥ë’¡×\n\n  #’¾ò’·ï’¡§\n  \n\n  #’Í×’µá’¡§\n  \n\n  #’²ò’Ë¡’¡§\n  ’¡Ö’°Ø’»Ò’Á´’ÂÎ’¤Î’Ä¹’¤µX’¥»’¥ó’¥Á’¥á’¡¼’¥È’¥ë - Z ’¡×’¡à ’¡ÖY+Z’¡× ’¤Î’¾Ï’¤ò’µá’¤á’¤ë’¡¥\n */\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nint main(void){\n  int X,Y,Z;\n  int ans;\n\n  cin>>X>>Y>>Z;\n  ans = (X-Z)/(Y+Z);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n" "5\n0 0\n7 3\n2 2\n4 8\n1 6\n8 5\n6 9\n5 4\n9 1\n3 7\n" "2\n2 2\n3 3\n0 0\n1 1\n" "5\n0 0\n7 3\n2 2\n4 8\n1 6\n8 5\n6 9\n5 4\n9 1\n3 7\n" "3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\n" "  FORQ(i,1,N){\n    cin>>a[i].ST>>s[i].ST;\n  }\n" "typedef pair<int, int> point_t;\npoint_t operator+( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n  return p;\n}\n\npoint_t operator-( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first - rhs.first, lhs.second - rhs.second);\n  return p;\n}\n\n\nbool operator==(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first == rhs.first) && (lhs.second == rhs.second);\n}\n\nbool operator!=(point_t &lhs, point_t &rhs)\n{\n  return (lhs.first != rhs.first) || (lhs.second != rhs.second);\n}\n\nbool is_in_field(int row, int col,  point_t &point){\n  const int r = point.first;\n  const int c = point.second;\n  return (1<= c && c<=col) && (1 <= r && r <= row);\n}\n" "point_t operator+( point_t &lhs, point_t &rhs)\n{\n  point_t p = make_pair(lhs.first + rhs.first, lhs.second + rhs.second);\n  return p;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-2 ) { \n      FOR ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-2 ) { \n      FOR ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-2 ) { \n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-2 ) { \n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-2 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-1 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,M){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-1 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,M){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-1 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,N){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-1 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,N){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n\n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n\n  do{\n    FORQ( i,1,v.size()-1 ) {\n      FORQ ( j,0,graph[v[i]].size() ) {\n        if(graph[v[i]][j]==v[i+1]){\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "    // cout<<\"loop2FailFlag: \"<<loop2FailFlag<<endl;" "        // loop3SucFlag=0; " "      // cout<<\"v[\"<<i<<\"]’¤Èv[\"<<i+1<<\"]’¤Î’´Ö’¤Ë’Æ»’¤¬’¤¢’¤ë’¤«’Ãµ’º÷\"<<endl;" "/*\n  #’Ìä’Âê’¡§\n\n\n\n  #’Ê¬’ÀÏ’¡§\n  #’¥ª’¥Ö’¥¸’¥§’¥¯’¥È’¡§\n  ’¡ÖN’¸Ä’¤Î’Äº’ÅÀ’¡×\n  ’¡ÖM’¸Ä’¤Î’ÊÕ’¡×\n\n  ’Îã’¤¨’¤Ð’¡¤\n\n\n  #’¾ò’·ï’¡§\n\n\n  #’Í×’µá’¡§\n  1’¥Î’¡¼’¥É’¤ò’»Ï’ÅÀ’¤È’¤·’¤Æ’Á´’¤Æ’¤Î’¥Î’¡¼’¥É’¤ò’ÄÌ’¤ë’¥Ñ’¥¹’¤Î’¿ô’¤ò’µá’¤á’¤¿’¤¤’¡¥\n\n\n  #’²ò’Ë¡’¡§\n\n\n\n*/\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,N){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  // FORQ(i,0,N){\n  //   int j=0;\n  //   for(auto x:graph[i]){\n  //     cout<<\"graph[\"<<i<<\"][\"<<j<<\"]: \"<<graph[i][j]<<endl;\n  //     j++;\n  //   }\n  //   cout<<endl<<endl;\n  // }\n  \n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n  // for(auto x: v) cout<<x ;\n  // cout<<endl;\n\n  do{\n    // FOR(i,0,3){\n    //   cout<<endl;\n    // }\n    // for(auto x: v) if(x!=0) cout<<x ;\n    // cout<<endl;\n    FORQ( i,1,v.size()-2 ) {\n      // cout<<\"v[\"<<i<<\"]’¤Èv[\"<<i+1<<\"]’¤Î’´Ö’¤Ë’Æ»’¤¬’¤¢’¤ë’¤«’Ãµ’º÷\"<<endl;\n      FORQ ( j,0,graph[v[i]].size() ) {\n\n        if(graph[v[i]][j]==v[i+1]){\n          // printf(\"graph[%d][%d] :%d\\n\",v[i],j,v[i+1]);\n          // printf(\"v[%d]: %d\\n\",i+1,v[i+1]);\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n      \n      // cout<<\"loop3SucFlag: \"<<loop3SucFlag<<endl;\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        // loop3SucFlag=0; \n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    // cout<<\"loop2FailFlag: \"<<loop2FailFlag<<endl;\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "/*\n  #’Ìä’Âê’¡§\n\n\n\n  #’Ê¬’ÀÏ’¡§\n  #’¥ª’¥Ö’¥¸’¥§’¥¯’¥È’¡§\n  ’¡ÖN’¸Ä’¤Î’Äº’ÅÀ’¡×\n  ’¡ÖM’¸Ä’¤Î’ÊÕ’¡×\n\n  ’Îã’¤¨’¤Ð’¡¤\n\n\n  #’¾ò’·ï’¡§\n\n\n  #’Í×’µá’¡§\n  1’¥Î’¡¼’¥É’¤ò’»Ï’ÅÀ’¤È’¤·’¤Æ’Á´’¤Æ’¤Î’¥Î’¡¼’¥É’¤ò’ÄÌ’¤ë’¥Ñ’¥¹’¤Î’¿ô’¤ò’µá’¤á’¤¿’¤¤’¡¥\n\n\n  #’²ò’Ë¡’¡§\n\n\n\n*/\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <bitset>     //UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>        //do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define uLL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\nconst int mod=1000000007;\n\nusing namespace std;\n\nvector<int> graph[1000];\n\nint main(void){\n  int N, M, Q;                  // ’Äº’ÅÀ’¤Î’¿ôN’¡¤’ÊÕ’¤Î’¿ôM’¡¤’¥¤’¥ó’¥×’¥Ã’¥È’¤Î’¿ôQ\n  cin>>N>>M;\n  int cnt=0;\n\n  FORQ(i,1,N){\n    graph[i].push_back(0);\n  }\n\n  FOR(i,0,N){\n    int a,b;\n    cin>>a>>b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  // FORQ(i,0,N){\n  //   int j=0;\n  //   for(auto x:graph[i]){\n  //     cout<<\"graph[\"<<i<<\"][\"<<j<<\"]: \"<<graph[i][j]<<endl;\n  //     j++;\n  //   }\n  //   cout<<endl<<endl;\n  // }\n  \n  int loop3SucFlag=0;\n  int loop2FailFlag=0;\n  vector<int> v(N+1);\n  FORQ(i,1,N){\n    v[i]=i;\n  }\n  // for(auto x: v) cout<<x ;\n  // cout<<endl;\n\n  do{\n    // FOR(i,0,3){\n    //   cout<<endl;\n    // }\n    // for(auto x: v) if(x!=0) cout<<x ;\n    // cout<<endl;\n    FORQ( i,1,v.size()-2 ) {\n      // cout<<\"v[\"<<i<<\"]’¤Èv[\"<<i+1<<\"]’¤Î’´Ö’¤Ë’Æ»’¤¬’¤¢’¤ë’¤«’Ãµ’º÷\"<<endl;\n      FORQ ( j,0,graph[v[i]].size() ) {\n\n        if(graph[v[i]][j]==v[i+1]){\n          // printf(\"graph[%d][%d] :%d\\n\",v[i],j,v[i+1]);\n          // printf(\"v[%d]: %d\\n\",i+1,v[i+1]);\n          loop3SucFlag=1;\n          break;\n        }else{\n        }\n      }\n      \n      // cout<<\"loop3SucFlag: \"<<loop3SucFlag<<endl;\n      if(loop3SucFlag==0){\n        loop2FailFlag=1;\n        loop3SucFlag=0; \n        break;\n      }\n      loop3SucFlag=0;\n    }\n\n    // cout<<\"loop2FailFlag: \"<<loop2FailFlag<<endl;\n    if(loop2FailFlag==0){\n      cnt++;\n    }\n    loop2FailFlag=0;\n    \n  }while(   next_permutation(  v.begin()+1,v.end()  )   &&  v[1]==1);\n\n  cout<<cnt<<endl;\n  return 0;\n}\n" "7 7\n1 3\n2 7\n3 4\n4 5\n4 6\n5 6\n6 7\n" "        // printf(\"graph[%d][%d] :%d\\n\",v[i],j,v[i+1]);\n        // printf(\"v[%d]: %d\\n\",i+1,v[i+1]);"))
(setq kill-ring-yank-pointer (nthcdr 0 kill-ring))

;; Buffer section -- buffers listed in same order as in buffer list:
(desktop-create-buffer 208
  "/Users/freedom/icpc/liblary.cpp"
  "liblary.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  8
  '(100 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (24 380 400 755))))

(desktop-create-buffer 208
  "/Users/freedom/.emacs.d/init.el"
  "init.el"
  'emacs-lisp-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  14355
  '(1480 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring nil)))

(desktop-create-buffer 208
  "/Users/freedom/icpc/Misterious_Gems.cpp"
  "Misterious_Gems.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  231
  '(3044 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (3368 2850 2700 2811 2849 3056 3158 3368 3341 2830 2830 54 71 215))))

(desktop-create-buffer 208
  "/Users/freedom/.emacs.d/mysnippets/c++-mode/vec.cpp"
  "vec.cpp"
  'snippet-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  66
  '(66 nil)
  nil
  nil
  '((buffer-file-coding-system . undecided-unix))
  '((mark-ring (52 66))))

(desktop-create-buffer 208
  "/Users/freedom/icpc/ICPC_Score_Totalizer_Software.cpp"
  "ICPC_Score_Totalizer_Software.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  2
  '(1363 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (1 1363 1253 1140 1045 1011 1159 1183 1269 1161 1158 1362 1362 1054 1091))))

(desktop-create-buffer 208
  "/Users/freedom/coder/C/One_Stroke_Path3.cpp"
  "One_Stroke_Path3.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  1532
  '(1262 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (1832 1 1475 803 1394 1551 1393 1128 1127 1258 1189 1601 1393 1370 1363 1532))))

(desktop-create-buffer 208
  "/Users/freedom/coder/2018602/B.cpp"
  "B.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  1
  '(nil nil)
  nil
  nil
  nil
  '((mark-ring nil)))

(desktop-create-buffer 208
  "/Users/freedom/coder/C/2D_Plane_2N_Points.cpp"
  "2D_Plane_2N_Points.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  2332
  '(2382 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (2352 2250 1972 2179 2131 2085 2026 1182 1351 1214 776 124 106 2450 33 2126))))

(desktop-create-buffer 208
  "/Users/freedom/coder/C/One_Stroke_Path.cpp"
  "One_Stroke_Path.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  136
  '(1919 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (1536 1353 1152 1919 1629 1554 1824 1 916 1126 1170 576 84 1254 1295 84))))

(desktop-create-buffer 208
  "/Users/freedom/coder/2018602/A.cpp"
  "A.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  1
  '(1 nil)
  nil
  nil
  nil
  '((mark-ring (1))))

(desktop-create-buffer 208
  "/Users/freedom/coder/C/2D_Plane_2N_Points3.cpp"
  "2D_Plane_2N_Points3.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  2723
  '(3254 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (3024 1 3200 2893 2737 2723))))

(desktop-create-buffer 208
  "/Users/freedom/coder/C/2D_Plane_2N_Points2.cpp"
  "2D_Plane_2N_Points2.cpp"
  'c++-mode
  '(abbrev-mode override-global-mode company-mode irony-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  2775
  '(3238 nil)
  nil
  nil
  '((buffer-file-coding-system . utf-8-unix))
  '((mark-ring (3107 2950 2974 3094 2975 2949 725 630 587 2816 2468 2834 2485 2775 2159 2023))))

(desktop-create-buffer 208
  nil
  "*info*"
  'Info-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  1491432
  '(1 nil)
  t
  '("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" ((history ("dir" "Top" 5207) ("dir" "Top" 227) ("dir" "Top" 173) ("dir" "Top" 173) ("dir" "Top" 227) ("dir" "Top" 227) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Top" 1702) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350))))
  '((tab-width . 8) (buffer-file-coding-system . utf-8-unix) (case-fold-search . t))
  '((mark-ring nil)))

(desktop-create-buffer 208
  nil
  "*info*<2>"
  'Info-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  227
  '(nil nil)
  t
  '("dir" "Top" ((history ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Top" 1702) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350))))
  '((tab-width . 8) (buffer-file-coding-system . utf-8-unix) (case-fold-search . t))
  '((mark-ring nil)))

(desktop-create-buffer 208
  nil
  "*info*<3>"
  'Info-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  227
  '(nil nil)
  t
  '("dir" "Top" ((history ("dir" "Top" 227) ("dir" "Top" 227) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Top" 1702) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350))))
  '((tab-width . 8) (buffer-file-coding-system . utf-8-unix) (case-fold-search . t))
  '((mark-ring nil)))

(desktop-create-buffer 208
  nil
  "*info*<4>"
  'Info-mode
  '(override-global-mode company-mode helm-mode linum-mode global-whitespace-mode undo-tree-mode yas-minor-mode)
  227
  '(nil nil)
  t
  '("dir" "Top" ((history ("dir" "Top" 227) ("dir" "Top" 173) ("dir" "Top" 173) ("dir" "Top" 227) ("dir" "Top" 227) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Top" 1702) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350) ("/Applications/Emacs.app/Contents/Resources/info/emacs" "Easy Customization" 1491350))))
  '((tab-width . 8) (buffer-file-coding-system . utf-8-unix) (case-fold-search . t))
  '((mark-ring nil)))

